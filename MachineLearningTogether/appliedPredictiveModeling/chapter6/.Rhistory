pcaObject <- prcomp(absorp,
center = TRUE,
scale. = TRUE
)
percentVariance <- pcaObject$sd^2/sum(pcaObject$sd^2)*100
plot(percentVariance)
varexp <- cumsum(percentVariance)
which(varexp >= 99.999999)
plot(varexp)
data <- data.frame(endpoints[,2], absorp)
names(data)[1] <- "fat"
nzr <- nearZeroVar(data, saveMetrics = TRUE)
hist(data$fat)
colSums(is.na(data))
trainingRows <- createDataPartition(data$fat, p = .8, list = FALSE)
trainingData <- data[trainingRows, ]
testData <- data[-trainingRows,]
set.seed(101)
lmFit <- train(fat ~ .,
data = trainingData,
method = "lm",
trControl = ctrl)
rlmPCA <- train(fat ~ .,
data = trainingData,
method = "rlm",
preProcess = "pca",
trControl = ctrl
)
ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 3)
lmFit <- train(fat ~ .,
data = trainingData,
method = "lm",
trControl = ctrl)
rlmPCA <- train(fat ~ .,
data = trainingData,
method = "rlm",
preProcess = "pca",
trControl = ctrl
)
lmFitPCA <- train(
fat ~ .,
data = trainingData,
method = "pcr",
scale = TRUE,
trControl = trainControl("cv", number = 10),
tuneLength = 100
)
resamp <- resamples(list(linear = lmFit,
linearPCA = lmFitPCA))
set.seed(101)
ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 3)
set.seed(101)
registerDoMC(cores = 5)
lmFit <- train(fat ~ .,
data = trainingData,
method = "lm",
trControl = ctrl)
set.seed(101)
lmFitPCA <- train(
fat ~ .,
data = trainingData,
method = "pcr",
scale = TRUE,
trControl = trainControl("cv", number = 10),
tuneLength = 100
)
resamp <- resamples(list(linear = lmFit,
linearPCA = lmFitPCA))
View(lmFit)
lmFitPCA <- train(
fat ~ .,
data = trainingData,
method = "pcr",
scale = TRUE,
trControl = ctrl,
tuneLength = 100
)
resamp <- resamples(list(linear = lmFit,
linearPCA = lmFitPCA))
?set.seed
set.seed(42); u1 <- runif(30)
set.seed(42); u2 <- runif(30)
stopifnot(identical(u1, u2))
identical(u1, u2)
set.seed(42)
u1 <- runif(30)
u2 <- runif(30)
identical(u1, u2)
################### ex. 6.1 pg. 137
library(caret)
library(doMC)
rm(list = ls())
cat("\014")
## a) load the dataset
data(tecator)
?tecator
## b) PCA APPLICATION
pcaObject <- prcomp(absorp,
center = TRUE,
scale. = TRUE
)
percentVariance <- pcaObject$sd^2/sum(pcaObject$sd^2)*100
plot(percentVariance)
varexp <- cumsum(percentVariance)
which(varexp >= 99.999999)
plot(varexp)
# i think that 20 is enough
### 3) select from different models
data <- data.frame(endpoints[,2], absorp)
names(data)[1] <- "fat"
nzr <- nearZeroVar(data, saveMetrics = TRUE)
hist(data$fat)
colSums(is.na(data))
# transBox <- BoxCoxTrans(data$fat)
# trans <- predict(trans, data$fat)
# hist(trans)
trainingRows <- createDataPartition(data$fat, p = .8, list = FALSE)
trainingData <- data[trainingRows, ]
testData <- data[-trainingRows,]
registerDoMC(cores = 5)
ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 3)
set.seed(101)
lmFit <- train(fat ~ .,
data = trainingData,
method = "lm",
trControl = ctrl)
set.seed(101)
lmFitPCA <- train(
fat ~ .,
data = trainingData,
method = "pcr",
scale = TRUE,
trControl = ctrl,
tuneLength = 100
)
rlmPCA <- train(fat ~ .,
data = trainingData,
method = "rlm",
preProcess = "pca",
trControl = ctrl
)
plsTune <- train(fat ~ .,
data = trainingData,
method = "pls",
tuneLength = 200,
trControl = ctrl,
preProc = c("center", "scale")
)
enetGrid <- expand.grid(.lambda = c(0, 0.01, .1),
.fraction = seq(.05, 1, length = 20)
)
enetTune <- train(fat ~ .,
data = trainingData,
method = "enet",
tuneGrid = enetGrid,
trControl = ctrl,
preProc = c("center", "scale")
)
resamp <- resamples(list(linear = lmFit,
linearPCA = lmFitPCA,
linearePLS = plsTune,
linearRObust = rlmPCA,
elasticNet = enetTune))
################### ex. 6.1 pg. 137
library(caret)
library(doMC)
rm(list = ls())
cat("\014")
## a) load the dataset
data(tecator)
?tecator
## b) PCA APPLICATION
pcaObject <- prcomp(absorp,
center = TRUE,
scale. = TRUE
)
percentVariance <- pcaObject$sd^2/sum(pcaObject$sd^2)*100
plot(percentVariance)
varexp <- cumsum(percentVariance)
which(varexp >= 99.999999)
plot(varexp)
# i think that 20 is enough
### 3) select from different models
data <- data.frame(endpoints[,2], absorp)
names(data)[1] <- "fat"
nzr <- nearZeroVar(data, saveMetrics = TRUE)
hist(data$fat)
colSums(is.na(data))
# transBox <- BoxCoxTrans(data$fat)
# trans <- predict(trans, data$fat)
# hist(trans)
trainingRows <- createDataPartition(data$fat, p = .8, list = FALSE)
trainingData <- data[trainingRows, ]
testData <- data[-trainingRows,]
registerDoMC(cores = 5)
ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 3)
set.seed(101)
lmFit <- train(fat ~ .,
data = trainingData,
method = "lm",
trControl = ctrl)
set.seed(101)
lmFitPCA <- train(
fat ~ .,
data = trainingData,
method = "pcr",
scale = TRUE,
trControl = ctrl,
tuneLength = 100
)
set.seed(101)
rlmPCA <- train(fat ~ .,
data = trainingData,
method = "rlm",
preProcess = "pca",
trControl = ctrl
)
set.seed(101)
plsTune <- train(fat ~ .,
data = trainingData,
method = "pls",
tuneLength = 200,
trControl = ctrl,
preProc = c("center", "scale")
)
enetGrid <- expand.grid(.lambda = c(0, 0.01, .1),
.fraction = seq(.05, 1, length = 20)
)
set.seed(101)
enetTune <- train(fat ~ .,
data = trainingData,
method = "enet",
tuneGrid = enetGrid,
trControl = ctrl,
preProc = c("center", "scale")
)
resamp <- resamples(list(linear = lmFit,
linearPCA = lmFitPCA,
linearePLS = plsTune,
linearRObust = rlmPCA,
elasticNet = enetTune))
bwplot(resamp)
resamp <- resamples(list(linear = lmFit,
linearPCA = lmFitPCA,
linearePLS = plsTune,
linearRobust = rlmPCA,
elasticNet = enetTune))
bwplot(resamp)
plsTune
lmFitPCA
.rs.restartR()
.rs.restartR()
?.rs.restartR
library(caret)
library(doMC)
rm(list = ls())
cat("\014")
library(AppliedPredictiveModeling)
library(permeability)
data(permeability)
dim(fingerprints)
fingerprints[1,]
nzr <- nearZeroVar(fingerprints, saveMetrics = TRUE)
View(nzr)
nzr[["nzr"]]
nzr[["nzr"]]
nzr[["nzv"]]
fingerprintsNoVar <- fingerprints[!nzr[["nzv"]],]
!nzr[["nzv"]]
fingerprintsNoVar <- fingerprints[!nzr[["nzv"]],]
nzr <- nearZeroVar(fingerprints)
fingerprintsNoVar <- fingerprints[!nzr,]
nzr
nzv <- nearZeroVar(fingerprints, saveMetrics = TRUE)
View(nzv)
fingerprintsNoVar <- fingerprints[-nzr,]
dim(fingerprintsNoVar)
dim(fingerprints)
nzr
fingerprintsNoVar <- fingerprints[-nzr,]
dim(fingerprintsNoVar)
dim(fingerprints)
library(AppliedPredictiveModeling)
data(permeability)
dim(fingerprints)
## b) filtering data
nzr <- nearZeroVar(fingerprints)
fingerprintsNoVar <- fingerprints[,-nzr]
dim(fingerprintsNoVar)
dim(fingerprints)
trainingRows <- createDataPartition(permeability, p = .8, list = FALSE)
data <- data.frame(permeability,fingerprintsNoVar)
data <- data.frame(permeability,fingerprintsNoVar)
colnames(data)[1] <- "permeability"
trainingRows <- createDataPartition(permeability, p = .8, list = FALSE)
trainingData <- data[trainingRows, ]
testData <- data[-trainingRows,]
registerDoMC(cores = 5)
ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 3)
set.seed(101)
plsTune <- train(fat ~ .,
data = trainingData,
method = "pls",
tuneLength = 200,
trControl = ctrl,
preProc = c("center", "scale")
)
plsTune <- train(permeability~ .,
data = trainingData,
method = "pls",
tuneLength = 200,
trControl = ctrl,
preProc = c("center", "scale")
)
plsTune
trainingData
permeability
View(trainingData)
head(data)
head(data,5)
plsTune <- train(permeability~ .,
data = trainingData,
method = "pls",
tuneLength = 100,
trControl = ctrl,
preProc = c("center", "scale")
)
plot(plsTune)
plsTune <- train(permeability~ .,
data = trainingData,
method = "pls",
tuneLength = 50,
trControl = ctrl,
preProc = c("center", "scale")
)
plot(plsTune)
plsTune
View(testData)
prediction <- predict(plsTune, testData[,-1])
lmPls <- data.frame(obs = testData$permeability, pred = prediction)
defaultSummary(lmPls)
set.seed(101)
plsTune <- train(permeability~ .,
data = trainingData,
method = "pls",
tuneLength = 50,
trControl = ctrl,
preProc = c("center", "scale")
)
plot(plsTune)
prediction <- predict(plsTune, testData[,-1])
lmPls <- data.frame(obs = testData$permeability, pred = prediction)
defaultSummary(lmPls)
set.seed(101)
lmFitPCA <- train(
permeability~ .,
data = trainingData,
method = "pcr",
preProcess = c("center", "scale"),
trControl = ctrl,
tuneLength = 100
)
set.seed(101)
rlmPCA <- train(permeability~ .,
data = trainingData,
method = "rlm",
preProcess = "pca",
trControl = ctrl
)
enetGrid <- expand.grid(.lambda = c(0, 0.01, .1),
.fraction = seq(.05, 1, length = 20)
)
set.seed(101)
enetTune <- train(permeability~ .,
data = trainingData,
method = "enet",
tuneGrid = enetGrid,
trControl = ctrl,
preProc = c("center", "scale")
)
resamp <- resamples(list(linearPCA = lmFitPCA,
linearePLS = plsTune,
linearRobust = rlmPCA,
elasticNet = enetTune))
bwplot(resamp)
hist(permeability)
transBox <- BoxCoxTrans(data$permeability)
a
transBox <- BoxCoxTrans(data$permeability)
trans <- predict(trans, data$permeability)
trans <- predict(transBox, data$permeability)
hist(trans)
data$permeability <- trans
trainingRows <- createDataPartition(permeability, p = .8, list = FALSE)
trainingData <- data[trainingRows, ]
testData <- data[-trainingRows,]
registerDoMC(cores = 5)
ctrl <- trainControl(method = "repeatedcv", number = 10, repeats = 3)
set.seed(101)
plsTune <- train(permeability~ .,
data = trainingData,
method = "pls",
tuneLength = 50,
trControl = ctrl,
preProc = c("center", "scale")
)
plot(plsTune)
prediction <- predict(plsTune, testData[,-1])
lmPls <- data.frame(obs = testData$permeability, pred = prediction)
defaultSummary(lmPls)
set.seed(101)
lmFitPCA <- train(
permeability~ .,
data = trainingData,
method = "pcr",
preProcess = c("center", "scale"),
trControl = ctrl,
tuneLength = 100
)
set.seed(101)
rlmPCA <- train(permeability~ .,
data = trainingData,
method = "rlm",
preProcess = "pca",
trControl = ctrl
)
enetGrid <- expand.grid(.lambda = c(0, 0.01, .1),
.fraction = seq(.05, 1, length = 20)
)
set.seed(101)
enetTune <- train(permeability~ .,
data = trainingData,
method = "enet",
tuneGrid = enetGrid,
trControl = ctrl,
preProc = c("center", "scale")
)
resamp <- resamples(list(linearPCA = lmFitPCA,
linearePLS = plsTune,
linearRobust = rlmPCA,
elasticNet = enetTune))
bwplot(resamp)
plot(lmPls$obs, lmPls$pred,
ylim = axisRange,
xlim = axisRange)
axisRange <- extendrange(c(lmPls$obs,lmPls$pred))
plot(lmPls$obs, lmPls$pred,
ylim = axisRange,
xlim = axisRange)
abline(0, 1, col = "darkgrey", lty = 2)
library(AppliedPredictiveModeling)
data(solubility)
ls(pattern = "^solT")
trainingData <- solTrainXtrans
trainingData$Solubility <- solTrainY
lmFitAllPredictors <- lm(Solubility ~ ., data = trainingData)
summary(lmFitAllPredictors)
library(caret)
lmPred1 <- predict(lmFitAllPredictors, solTestXtrans)
lmValues1 <- data.frame(obs = solTestY, pred = lmPred1)
defaultSummary(lmValues1)
ctrl <- trainControl(method = "cv", number = 10)
set.seed(100)
lmFit1 <- train(x = solTrainXtrans,
y = solTrainY,
method = "lm",
trControl = ctrl
)
xyplot(solTrainY ~ predict(lmFit1),
type = c("p", "g"),  #plot the points (type ='p') and a background grid     ('g')
xlab = "Predicted",
ylab = "Observed"
)
xyplot(solTrainY ~ predict(lmFit1),
type = c("p", "g"),  #plot the points (type ='p') and a background grid     ('g')
xlab = "Predicted",
ylab = "Observed"
)
xyplot(resid(lmFit1) ~ predict(lmFit1),
type = c("p", "g"),
xlab = "Predicted",
ylab = "Residuals")
corThresh <- .9
tooHigh <- findCorrelation(cor(solTrainXtrans), corThresh)
corrPred <- names(solTrainXtrans)[tooHigh]
trainXfiltered <- solTrainXtrans[, -tooHigh]
testXfiltered <- solTestXtrans[, -tooHigh]
set.seed(100)
lmFiltered <- train(solTrainXtrans, solTrainY, method = "lm",                    trControl = ctrl)
lmFiltered
library(MASS)
rlmFitAllPredictors <- rlm(Solubility ~ ., data = trainingData)
summary(rlmFitAllPredictors)
modelPCA <- train(
Solubility ~ .,
data = trainingData,
method = "pcr",
scale = TRUE,
trControl = trainControl("cv", number = 10),
tuneLength = 228
)
print(modelPCA)
plot(modelPCA)
print(plsTune)
print(modelPCA)
plsTune <- train(solTrainXtrans, solTrainY,
method = "pls",
tuneLength = 200,
trControl = ctrl,
preProc = c("center", "scale")
)
print(plsTune)
